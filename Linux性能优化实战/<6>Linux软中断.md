# Linux 软中断

**中断其实是一种异步的事件处理机制，可以提高系统的并发处理能力**。

由于中断处理程序会打断其他进程的运行，所以，**为了减少对正常进程运行调度的影响，中断处理程序就需要尽可能快地运行**。如果中断本身要做的事情不多，那么处理起来也不会有太大问题；但如果中断要处理的事情很多，中断服务程序就有可能要运行很长时间。

特别是，中断处理程序在响应中断时，还会临时关闭中断。这就会导致上一次中断处理完成之前，其他中断都不能响应，也就是说中断有可能会丢失。

为了解决中断处理程序执行过长和中断丢失的问题，Linux 将中断处理过程分成了两个阶段，也就是**上半部和下半部**：

- **上半部用来快速处理中断**，它在中断禁止模式下运行，主要处理跟硬件紧密相关的或时间敏感的工作。
- **下半部用来延迟处理上半部未完成的工作，通常以内核线程的方式运行**。

简单理解：

- 上半部直接处理硬件请求，也就是我们常说的硬中断，特点是快速执行；（比如键盘、鼠标的输入，硬盘的写入读取、网卡有数据了；）
- 而下半部则是由内核触发，也就是我们常说的软中断，特点是延迟执行。（软中断是软件产生的，比如程序内的定时器、[文中提到的RCU锁]）



**查看软中断和内核线程**

- /proc/softirqs 提供了软中断的运行情况；
- /proc/interrupts 提供了硬中断的运行情况。

例：

```
# 软中断的十个类型 待验证
$ cat /proc/softirqs
                   CPU0       CPU1
          HI:          0          0       优先级高的tasklets  
       TIMER:     811613    1972736				定时器的下半部
      NET_TX:         49          7       网络发送中断
      NET_RX:    1136736    1506885       网络接受中断
       BLOCK:          0          0       BLOCK装置
    IRQ_POLL:          0          0
     TASKLET:     304787       3691       正常优先级的tasklets
       SCHED:     689718    1897539       调度程序
     HRTIMER:          0          0       高分辨率定时器
         RCU:    1330771    1354737       RCU锁定
```

同一种软中断在不同 CPU 上的分布情况，也就是同一行的内容。正常情况下，同一种中断在不同 CPU 上的累积次数应该差不多。

**查看软中断线程的运行状况**

软中断实际上是以内核线程的方式运行的，每个 CPU 都对应一个软中断内核线程，这个软中断内核线程就叫做 ksoftirqd/CPU 编号

```
$ ps aux | grep softirq
root         7  0.0  0.0      0     0 ?        S    Oct10   0:01 [ksoftirqd/0]
root        16  0.0  0.0      0     0 ?        S    Oct10   0:01 [ksoftirqd/1]
```

注意，这些线程的名字外面都有中括号，这说明 ps 无法获取它们的命令行参数（cmline）。一般来说，ps 的输出中，名字括在中括号里的，一般都是内核线程。



**小结**

Linux 中的中断处理程序分为上半部和下半部：

- 上半部对应硬件中断，用来快速处理中断。
- 下半部对应软中断，用来异步处理上半部未完成的工作。

Linux 中的软中断包括网络收发、定时、调度、RCU 锁等各种类型，可以通过查看 /proc/softirqs 来观察软中断的运行情况。



## 系统的软中断CPU使用率升高

